/**
 * CpgMultiMetricsStats.java
 * Feb 27, 2016
 * 5:28:37 PM
 * yaping    lyping1986@gmail.com
 */
package org.cchmc.epifluidlab.finaleme.utils;


import htsjdk.samtools.*;
import htsjdk.samtools.util.IntervalTree;
import htsjdk.samtools.util.IntervalTree.Node;
import htsjdk.samtools.util.SequenceUtil;
import org.apache.log4j.Logger;
import org.biojava.nbio.genome.parsers.twobit.TwoBitParser;
import org.broadinstitute.gatk.utils.BaseUtils;
import org.kohsuke.args4j.Argument;
import org.kohsuke.args4j.CmdLineException;
import org.kohsuke.args4j.CmdLineParser;
import org.kohsuke.args4j.Option;

import java.io.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

/**
 *
 */
public class CpgMultiMetricsStatsV2 {

	@Option(name="-minBaseQ",usage="minimum base quality score required to check for CpG. Default: 5")
	public int minBaseQ = 5;

	@Option(name="-minMapQ",usage="minimum mapping quality score required to check. Default: 30")
	public int minMapQ = 30;

	@Option(name="-maxFragLen",usage="maximum fragment length allowed to check. Default: 1000")
	public int maxFragLen = 1000;

	@Option(name="-totalReadsInBam",usage="total number of reads used to normalize coverage column. default estimate from bam file by program. Default: -1")
	public long totalReadsInBam = -1;
	
	@Option(name="-maxCov",usage="maximum coverage allowed to check. Default: 250")
	public int maxCov = 250;
	
	@Option(name="-kmerLen",usage="the K-mer length to check. -kmerLen 3 means XXXCGXXX Default: 3")
	public int kmerLen = 3;
	
	@Option(name="-excludeRegions",usage="bed files indicated excluded regions. -excludeRegions trackFileName. Default: null")
	public ArrayList<String> excludeRegions = null;

	@Option(name="-wgsMode",usage="used for WGS but not bisulfite space. . Default: false")
	public boolean wgsMode = false;

	@Option(name="-skipSecondEnd",usage="skip the 2nd end for the statistics. Default: false")
	public boolean skipSecondEnd = false;

	@Option(name="-stringentPaired",usage="Only use paired end reads that faced to each other. Default: false")
	public boolean stringentPaired = false;
	
	@Option(name="-useStrand",usage="use k-mer generated by aware the strand of fragment status. Default: false")
	public boolean useStrand = false;
	
	@Option(name="-useNoChrPrefixBam",usage="use bam file with GRch37 instead of hg19 coordinate. Default: false")
	public boolean useNoChrPrefixBam = false;
	
	@Option(name="-h",usage="show option information")
	public boolean help = false;

	
	@Argument
	private List<String> arguments = new ArrayList<String>();

	final private static String USAGE = "CpgMultiMetricsStats [opts] hg19.2bit cpg_list.bed all_cpg.bed wgs.bam cpg_detail.txt.gz";
	
	private static Logger log = Logger.getLogger(CpgMultiMetricsStatsV2.class);

	private static long startTime = -1;
	private static long points = 0;


	/**
	 * @param args
	 * @throws Exception 
	 */
	public static void main(String[] args) throws Exception {
		CpgMultiMetricsStatsV2 cmms = new CpgMultiMetricsStatsV2();
		//BasicConfigurator.configure();
		cmms.doMain(args);
	}
	
	@SuppressWarnings("resource")
	public void doMain(String[] args)
			throws Exception {

					CmdLineParser parser = new CmdLineParser(this);
					//parser.setUsageWidth(80);
					try
					{
						if(help || args.length < 4) throw new CmdLineException(parser, USAGE, new Throwable());
						parser.parseArgument(args);
						
					
					}
					catch (CmdLineException e)
					{
						System.err.println(e.getMessage());
						// print the list of available options
						parser.printUsage(System.err);
						System.err.println();
						return;
					}

					//read input bed file, for each row,
					//String intervalFile = arguments.get(0);
					String refFile = arguments.get(0);
					String cpgListFile = arguments.get(1);
					String wgsBamFile = arguments.get(2);
					String detailFile = arguments.get(3);

					initiate();			
					
					//initiate different kinds of reader
					//reference genome
					TwoBitParser refParser = new TwoBitParser(new File(refFile));
					
					//String[] names = p.getSequenceNames();
					//for(int i=0;i<names.length;i++) {
					//  p.setCurrentSequence(names[i]);
					//  p.printFastaSequence();
					//  p.close();
					//}
					//loading exlusion interval file

					//load interval files
					log.info("Processing interval file ... ");
					SamReader wgsReader = SamReaderFactory.makeDefault().validationStringency(ValidationStringency.SILENT).open(new File(wgsBamFile));
					//SAMSequenceDictionary dictSeq = SAMSequenceDictionaryExtractor.extractDictionary(new File(wgsBamFile));
					//GenomeLocParser glpSeq = new GenomeLocParser(dictSeq);
					
					HashMap<String,IntervalTree<Integer>> ignoreLocCollections = null;
					if(excludeRegions!=null && !excludeRegions.isEmpty()){
						log.info("Excluding intervals ... ");
						ignoreLocCollections = new HashMap<String,IntervalTree<Integer>>();
						
						for(String excludeRegion : excludeRegions){
							BufferedReader br = new BufferedReader(new FileReader(excludeRegion));
							String line;
							
							while( (line = br.readLine()) != null){
								if(line.startsWith("#"))
									continue;
								String[] splitLines = line.split("\t");
								if(splitLines.length<3){
									continue;
								}
								String chr = splitLines[0];
								int start = Integer.parseInt(splitLines[1]);
								int end = Integer.parseInt(splitLines[2]);
								IntervalTree<Integer> tree;
								if(ignoreLocCollections.containsKey(chr)){
									tree = ignoreLocCollections.get(chr);
								}else{
									tree = new IntervalTree<Integer>();
								}
								tree.put(start, end, 1);
								ignoreLocCollections.put(chr, tree);
							}
							br.close();
						
						}
					}
					


					
					String header = "";

					if(kmerLen>0) {
						header = header + "\tkmer";
					}
					
					
					log.info("Loading CpG interval file ... ");
					HashMap<String,IntervalTree<String>> cpgCollections = new HashMap<String,IntervalTree<String>>();
						GZIPInputStream gzipInputStream1 = null;
						BufferedReader br;
						if(cpgListFile.endsWith(".gz")){
							gzipInputStream1 = new GZIPInputStream(new FileInputStream(cpgListFile));
							br = new BufferedReader(new InputStreamReader(gzipInputStream1));
							
						}else{
							br = new BufferedReader(new FileReader(cpgListFile));
						}
							
							String line;
							
							while( (line = br.readLine()) != null){
								if(line.startsWith("#"))
									continue;
								String[] splitLines = line.split("\t");
								if(splitLines.length<3){
									continue;
								}
								String chr = splitLines[0];
								int start = Integer.parseInt(splitLines[1]);
								int end = Integer.parseInt(splitLines[2]);
								IntervalTree<String> tree;
								
								if(cpgCollections.containsKey(chr)){
									tree = cpgCollections.get(chr);
								}else{
									tree = new IntervalTree<String>();
								}
								String strand = ".";
								if(splitLines.length >= 6){
									if(splitLines[5].equalsIgnoreCase("-")){
										strand = "-";
									}else if(splitLines[5].equalsIgnoreCase("+")){
										strand = "+";
									}
									//strand = splitLines[5].equalsIgnoreCase("-") ? "-" : "+";
								}
								tree.put(start, end, strand);
								cpgCollections.put(chr, tree);
							}
							if(cpgListFile.endsWith(".gz")){
								gzipInputStream1.close();
							}
							br.close();

					
					double readsNumTotal = 0;
					if(totalReadsInBam > 0){
						log.info("Get total reads number used for scaling from input option -totalReadsInBam ... ");
						readsNumTotal = totalReadsInBam;
					}else{
						log.info("Get total reads number used for scaling from bam file... ");
						SAMRecordIterator wgsIt = wgsReader.iterator();
						
						while(wgsIt.hasNext()){
							SAMRecord r = wgsIt.next();
							if(failFlagFilter(r)){
								continue;
							}else{
								if(stringentPaired && !CcInferenceUtils.passReadPairOrientation(r)){
									continue;
								}
							
							}
							readsNumTotal++;
						}
						wgsIt.close();
					}
					
					log.info((long)readsNumTotal + " reads in total ...");
					readsNumTotal = readsNumTotal/1000000;
					log.info("Output value for each CpG in each DNA fragment ... ");
					FileOutputStream output = new FileOutputStream(detailFile);
					OutputStreamWriter writer = new OutputStreamWriter(new GZIPOutputStream(output), "UTF-8");
					
					//basic
					writer.write("chr\tstart\tend\treadName\tFragLen\tFrag_strand\tmethy_stat\tNorm_Frag_cov\tbaseQ\tOffset_frag\tDist_frag_end");
					writer.write(header + "\n");
					//fragment k-mer
					
					
					//
					
					long i = 0;
					String prevChr = "";
					for(String chr : cpgCollections.keySet()){
						if(chr.equalsIgnoreCase("chrM")){
							continue;
							
						}
						if(prevChr.equalsIgnoreCase("")){
							prevChr = chr;
							refParser.setCurrentSequence(chr);
						}
						String bamChr = chr;
						if(useNoChrPrefixBam){
							
							Pattern replace = Pattern.compile("^chr");
			                Matcher matcher1 = replace.matcher(bamChr);
			                bamChr=matcher1.replaceAll("");
						}
						IntervalTree<String> cpgChrCollections = cpgCollections.get(chr);
						Iterator<Node<String>> cpgIterator = cpgChrCollections.iterator();
						while(cpgIterator.hasNext()){
							Node<String> cpg = cpgIterator.next();
							int start = cpg.getStart();
							int end = cpg.getEnd();
							int fragMostLeft = start+1;
							int fragMostRight = end;
							
							SAMRecordIterator wgsIt = wgsReader.queryOverlapping(bamChr,start+1,end);//start 1-based, inclusive start of interval of interest. Zero implies start of the reference sequence.
							HashMap<String, SAMRecord> countedReads = new HashMap<String, SAMRecord>();
							//log.info("testincpg" + i + "\t" + cpgCollections.size() + "\t" + wgsIt.hasNext() + "\t" + chr + "\t" + start + "\t" + end);
							int readNumber =0;
							//log.info(r.getReadName() + "\t" + failFlagFilter(r));
							while(wgsIt.hasNext()){
								SAMRecord r = wgsIt.next();
								//log.info(r.getReadName() + "\t" + failFlagFilter(r));
								if(failFlagFilter(r)){
									continue;
								}else{
									if(stringentPaired && !CcInferenceUtils.passReadPairOrientation(r)){
										continue;
									}
									readNumber++;
									boolean negStrand = r.getReadNegativeStrandFlag();
									boolean secondEnd = r.getReadPairedFlag() && r.getSecondOfPairFlag();
									if(secondEnd){
										negStrand = !negStrand;
									}
									
									int bisulfitePos = 0;
									if(!wgsMode){
										if(r.getTransientAttribute("BS") != null){ //if the reads had been processed before
											bisulfitePos = Integer.parseInt((String) r.getTransientAttribute("BS"));
										}else{
											bisulfitePos = CcInferenceUtils.bisulfiteIncompleteReads(r);
											r.setTransientAttribute("BS", bisulfitePos);
											
										}
									}
									
									//log.info("testin" + readsNumTotal + "\t" + bisulfitePos);
									int offSet = r.getReadPositionAtReferencePosition(end)-1;
									if(bisulfitePos < 0){
										continue;
									}else if(bisulfitePos > 0){
										if((!negStrand && offSet < bisulfitePos) || (negStrand && offSet >= bisulfitePos)){
											continue;
										}
									}
									if(offSet<0){
									//	log.info(r.getReadName() + "\t" + offSet + "\t" + end + "\t" + r.getAlignmentStart() + "\t" + r.getAlignmentEnd());
									continue;
									}
									
									if(r.getAlignmentStart() < fragMostLeft){
										fragMostLeft = r.getAlignmentStart();
									}
									if(r.getMateAlignmentStart() < fragMostLeft){
										fragMostLeft = r.getMateAlignmentStart();
									}
									
									if(r.getAlignmentEnd() > fragMostRight){
										fragMostRight = r.getAlignmentEnd();
									}
									int mateEnd = CcInferenceUtils.getMateAlignmentEndByMateCigar(r);
									if(mateEnd > fragMostRight){
										fragMostRight = mateEnd;
									}
									
									String readName = r.getReadName();
									if(countedReads.containsKey(readName)){//to filter overlapped fragments, which affect a lot in cfDNA
										SAMRecord prev = countedReads.get(readName);
										int offSetPrev = prev.getReadPositionAtReferencePosition(end)-1;
										if(offSet < r.getBaseQualities().length && offSetPrev < prev.getBaseQualities().length){
											byte baseQ = r.getBaseQualities()[offSet];
											byte base = CcInferenceUtils.toUpperCase(r.getReadBases()[offSet]);
											
											
											byte baseQPrev = prev.getBaseQualities()[offSetPrev];
											byte basePrev = CcInferenceUtils.toUpperCase(prev.getReadBases()[offSetPrev]);
											
											if(!BaseUtils.basesAreEqual(base, basePrev)){
												if(baseQ > baseQPrev){
													countedReads.put(readName, r);
												}else if(baseQ < baseQPrev){
													
												}else{
													if(!secondEnd){
														countedReads.put(readName, r);
													}
												}
											}
										}
										
										
									}else{
										countedReads.put(readName, r);
									}
								}
								
							}
							wgsIt.close();
						//if(end==152011200){
						//	log.info(countedReads.size() + " reads finally used ...");
						//}
						//log.info(countedReads.size() + " reads finally used ...");
						if(readNumber >= maxCov || countedReads.size()==0){
							continue;
						}
						//log.info("test" + readsNumTotal + "\t" + countedReads.size());
						double normalizedFragCov = (double)readNumber/readsNumTotal;
						//System.err.println(normalizedFragCov + "\t" + countedReads.size() + "\t" + readsNumTotal);
						
						//System.err.println(normalizedFragCov + "\t" + countedReads.size() + "\t" + readsNumTotal);
						if(!chr.equalsIgnoreCase(prevChr)){
							refParser.close();
							refParser.setCurrentSequence(chr);
							prevChr = chr;
						}
						byte[] refBasesExt = CcInferenceUtils.toUpperCase(refParser.loadFragment(end-2-kmerLen, kmerLen*2+3).getBytes());
						byte refBase = refBasesExt[kmerLen+1];
						
						//if(end==152011200){
						//	log.info(new String(refBasesExt) + "\t" + (end-1-kmerExt) + "\t" + (kmerExt*2+1) + "\t" + kmerExt + "\t" + (char)refBasesExt[kmerExt]);
							
						//}
						
						for(String readName : countedReads.keySet()){
							SAMRecord r = countedReads.get(readName);
							boolean negStrand = r.getReadNegativeStrandFlag();
							boolean secondEnd = r.getReadPairedFlag() && r.getSecondOfPairFlag();
							if(secondEnd){
								negStrand = !negStrand;
							}
							int offSet = r.getReadPositionAtReferencePosition(end)-1;
							if(offSet<0){ //even it is within the reference interval, but it might be Deletion in the reads
								continue;
							}
							char methyStat = '.';
							byte[] bases = r.getReadBases();
							
							//System.err.println(readName + "\t" + offSet + "\t" + new String(bases) + "\t" + negStrand + "\t" + secondEnd + "\t" + end + "\t" + r.getAlignmentStart() + "\t" + r.getAlignmentEnd());
							byte base = bases[offSet];
							byte[] baseQs = r.getBaseQualities();
							byte baseQ = baseQs[offSet];
							if(baseQ <= minBaseQ){
								continue;
							}
							//if(end==152011200){
								//log.info(readName + "\t" + refBase);
							//}
							if(negStrand){
								//if(end==152011200){
									//log.info(refBase + "\t" + base + "\t" + BaseUtils.basesAreEqual(refBase, BaseUtilsMore.G) + "\t" + BaseUtils.basesAreEqual(base, BaseUtilsMore.G) + "\t" + BaseUtils.basesAreEqual(base, BaseUtilsMore.A));
								//}
								if(BaseUtils.basesAreEqual(refBase, BaseUtilsMore.G)){
									if(BaseUtils.basesAreEqual(base, BaseUtilsMore.G)){
										methyStat = 'm';
									}else if(BaseUtils.basesAreEqual(base, BaseUtilsMore.A)){
										methyStat = 'u';
									}else{
										continue;
									}
								}else{
									continue;
								}
							}else{
								//if(end==152011200){
									//log.info(refBase + "\t" + base + "\t" + BaseUtils.basesAreEqual(refBase, BaseUtilsMore.C) + "\t" + BaseUtils.basesAreEqual(base, BaseUtilsMore.C) + "\t" + BaseUtils.basesAreEqual(base, BaseUtilsMore.T));
								//}
								if(BaseUtils.basesAreEqual(refBase, BaseUtilsMore.C)){
									if(BaseUtils.basesAreEqual(base, BaseUtilsMore.C)){
										methyStat = 'm';
									}else if(BaseUtils.basesAreEqual(base, BaseUtilsMore.T)){
										methyStat = 'u';
									}else{
										continue;
									}
								}else{
									continue;
								}
							}
							
							//if(end==152011200){
								//log.info("after " + readName);
							//}
							
							int fragLen = Math.abs(r.getInferredInsertSize());
							if(fragLen > maxFragLen || fragLen == 0){
								continue;
							}
							//int cpgOffset = CcInferenceUtils.getFragOffsetFromReadsOffset(r, offSet);
							//int distToFragEnd = Math.min((fragLen-cpgOffset), cpgOffset);
							int cpgOffset = end - Math.min(r.getAlignmentStart(),r.getMateAlignmentStart());
							if(negStrand){
								cpgOffset = fragLen-cpgOffset;
							}
							int distToFragEnd = Math.min((fragLen-cpgOffset), cpgOffset);

							char fragStrand = negStrand ? '-' : '+';
							
							
							//get k-mer for the fragment

							
							//byte[] refBasesFragAll = refParser.loadFragment(fragMostLeft, fragMostRight-fragMostLeft+1).getBytes();
							//byte[] refBasesFrag = new byte[fragLen]; //TODO check if it is correct here!!!!
							//System.err.println(r.getAlignmentStart() + "\t" + r.getMateAlignmentStart() + "\t" + fragLen + "\t" + refBasesFragAll.length + "\t" + fragStart + "\t" + fragMostLeft + "\t" + r.getReadName());
							//for(int j = fragStart-fragMostLeft, index = 0; index < fragLen; j++, index++){ 
							//	refBasesFrag[index] = refBasesFragAll[j];
							//}
							byte[] refBasesFrag = negStrand ? Arrays.copyOfRange(refBasesExt, 0, kmerLen*2+2): Arrays.copyOfRange(refBasesExt, 1, kmerLen*2+3);
							if(negStrand && useStrand){
								SequenceUtil.reverseComplement(refBasesFrag);
							}

							
							
								//System.err.println(CcInferenceUtils.getFragOffsetFromReadsOffset(r, offSet));
							writer.write(chr + "\t" + start + "\t" + end + "\t" + readName + "\t" + fragLen + "\t" + fragStrand + "\t" + methyStat + "\t" + String.format("%.6f",normalizedFragCov)
									 + "\t" + (int)baseQ + "\t" + cpgOffset + "\t" + distToFragEnd);

							//k-mer in reference genome
							//if(kmerMapsRef.size()>0 && useRefSeqBaseKmer){
							if(kmerLen>0 ){
								writer.write("\t" + new String(refBasesFrag));
							}
							
							writer.write("\n");
							points++;
							
							
						}
						i++;
						if(i % 1000 == 0){
							log.info("Processing Cpg " + i + " ...");
							writer.flush();
						}
						}
					}
					writer.close();
					output.close();
					
					
					wgsReader.close();
					refParser.closeParser();;
					
					finish();

	}
	
	
	private boolean failFlagFilter(SAMRecord r){
		return r.getReadUnmappedFlag() || r.getNotPrimaryAlignmentFlag() || r.getMappingQuality() < minMapQ
				|| r.getReadFailsVendorQualityCheckFlag() || r.getDuplicateReadFlag() || !r.getReadPairedFlag() || !r.getProperPairFlag()
				|| (skipSecondEnd && r.getReadPairedFlag() && r.getSecondOfPairFlag());
	}
	

	
	
	private void initiate(){
		startTime = System.currentTimeMillis();
	}

	private void finish(){
		long endTime   = System.currentTimeMillis();
		double totalTime = endTime - startTime;
		totalTime /= 1000;
		double totalTimeMins = totalTime/60;
		double totalTimeHours = totalTime/3600;
		
		log.info("Counted " + points + " data points in total");
		log.info("CpgMultiMetricsStatsV2's running time is: " + String.format("%.2f",totalTime) + " secs, " + String.format("%.2f",totalTimeMins) +  " mins, " + String.format("%.2f",totalTimeHours) +  " hours");
	}
	

}
